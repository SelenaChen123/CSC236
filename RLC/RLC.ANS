Test date: 04/08/20  16:57:24 
The number of times you used the grading program is 13 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
RLC Grading System Version 4.0
Student: St#1=Chen                 St#2t=Verma                Type=Team                
Grading and testing history log
       User Test.    Date: 04/08/20  15:51:15  1            Display      
       User Test.    Date: 04/08/20  15:51:25  2            Display      
       User Test.    Date: 04/08/20  15:51:33  3            Display      
   *** Grading Run.  Date: 04/08/20  15:51:55 
       User Test.    Date: 04/08/20  16:09:20  1            Display      
       User Test.    Date: 04/08/20  16:09:39  1            Display      
       User Test.    Date: 04/08/20  16:09:48  1            Display      
       User Test.    Date: 04/08/20  16:10:43  1            Display      
       User Test.    Date: 04/08/20  16:11:43  1            Display      
       User Test.    Date: 04/08/20  16:14:04  1            Display      
       User Test.    Date: 04/08/20  16:14:30  1            Display      
       User Test.    Date: 04/08/20  16:17:25  1            Display      
       User Test.    Date: 04/08/20  16:17:37  2            Display      
       User Test.    Date: 04/08/20  16:17:38  3            Display      
   *** Grading Run.  Date: 04/08/20  16:17:42 
       User Test.    Date: 04/08/20  16:18:04  1            Display      
   *** Grading Run.  Date: 04/08/20  16:18:07 
       User Test.    Date: 04/08/20  16:24:25  1            Display      
       User Test.    Date: 04/08/20  16:25:46  1            Display      
       User Test.    Date: 04/08/20  16:25:48  2            Display      
       User Test.    Date: 04/08/20  16:27:19  1            Display      
       User Test.    Date: 04/08/20  16:27:20  2            Display      
   *** Grading Run.  Date: 04/08/20  16:27:23 
       User Test.    Date: 04/08/20  16:31:37  1            Display      
       User Test.    Date: 04/08/20  16:32:08  1            Display      
   *** Grading Run.  Date: 04/08/20  16:32:10 
       User Test.    Date: 04/08/20  16:36:08  1            Display      
   *** Grading Run.  Date: 04/08/20  16:36:10 
       User Test.    Date: 04/08/20  16:42:48  1            Display      
   *** Grading Run.  Date: 04/08/20  16:42:49 
       User Test.    Date: 04/08/20  16:43:45  1            Display      
   *** Grading Run.  Date: 04/08/20  16:43:47 
       User Test.    Date: 04/08/20  16:45:39  1            Display      
   *** Grading Run.  Date: 04/08/20  16:45:40 
       User Test.    Date: 04/08/20  16:50:08  1            Display      
   *** Grading Run.  Date: 04/08/20  16:50:10 
       User Test.    Date: 04/08/20  16:50:52  1            Display      
   *** Grading Run.  Date: 04/08/20  16:50:53 
       User Test.    Date: 04/08/20  16:52:17  1            Display      
       User Test.    Date: 04/08/20  16:52:46  1            Display      
   *** Grading Run.  Date: 04/08/20  16:52:49 
       User Test.    Date: 04/08/20  16:57:22  1            Display      
   *** Grading Run.  Date: 04/08/20  16:57:24 

Testing 1 dimension compression
Your output is correct
Your output is correct
Your output is correct

+  Your executed instruction count for tests run = 00008290
+   
+  Target instructions executed for tests run is:
+  20 points 00000 - 07999 
+  15 points 08000 - 09999 
+  10 points 10000 - 11999 
+   5 points 12000 - 13999 
+   0 points 14001 +       
+                          

++ Grade ++   15 = Points earned for code executed efficiency!

1 dimension compression is working

The following is credit earned for 1-dim compression

++ Grade ++  040 = Points earned for correct answers.

-> We are now analyzing your source code. You will be graded on
the number of instructions you wrote to solve this problem.
The target for the number of executable instructions written is:
 00 -  44 = 20 points 
 45 -  49 = 15 points 
 50 -  54 = 10 points 
 55 -  59 =  5 points 
 60+      =  0 points 
Your actual counts are:
Lines ....... 121    Comments ...  63    Labels .......   7   
Directives ..   6    Variables ..   4    Executables ..  41    McCabe ..   5 
++ Grade ++   20 = Points earned for code written efficiency.  

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0024 The program header format is adequate. 
DOCHB-0.63 Use of code block headers is adequate. 
DOCLC-1.00 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++   95 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    30  = Number of user tests.                                  
    13  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC:6&}xC86&k~C7;&juiC86&zuzC?;&Zkyz&jgzk@&6:56>586&&7<@;=@8:&

Building the file rlc.ans for electronic submission...

;-------------------------------------------------------------------------------------
;  Program:      Run Length Coding
;
;  Function:     Decompresses 1 dimensional run lengths. This subroutine links with a
;                C main program. Run-length coding (RLC) is a form of data compression
;                for such data types in which runs of data are stored as a single data
;                value (black or white) and a count specifying the run length.
;
;  Input:        A pointer to the compressed data which consists of strings of runs
;                and features. A pointer to a buffer, into which RLC is to decompress
;                the data to recreate the original character array
;
;  Output:       The decompressed data is placed into the output buffer.
;
;  Owner:        Selena Chen (schen53)
;                Ayushi Verma (averma6)
;
;  Date:         04/08/20
;
;  Changes:      05/16/2017    Original version ... coded to spec design
;                04/05/2020    First draft
;                04/07/2020    Working draft
;                04/08/2020    Completed version
;-------------------------------------------------------------------------------------
         .model    small
         .8086
         public    _rlc
;-----------------------------------------------
         .data                                 ;start the data segment
;-----------------------------------------------
wh       db        32                          ;white ascii value
blk      db        219                         ;black ascii value
is_left  db        1                           ;is it left 4 bits of byte
pels     db        80                          ;number of pels left
;-----------------------------------------------
         .code                                 ;start the code segnment
;-----------------------------------------------
; Save the registers ... 'C' requires (bp,si,di)
; Access the input and output lists
;-----------------------------------------------
_rlc:                                          ;
         push      bp                          ;save 'C' register
         mov       bp,sp                       ;set bp to point to stack
         push      si                          ;save 'C' register
         push      di                          ;save 'C' register
         mov       si,[bp+4]                   ;si points to the input compressed data
         mov       di,[bp+6]                   ;di points to the empty output buffer
;-----------------------------------------------
; Sets up white as first color being used and
; initializes cx to 0
;-----------------------------------------------
         mov       bl,[wh]                     ;begin with white color
         mov       cx,0                        ;clears cx register
         cld                                   ;clears direction flag for load/store
;-----------------------------------------------
; Gets each byte from input buffer
;-----------------------------------------------
load:                                          ;
         lodsb                                 ;loads input byte into al
         cmp       al,00h                      ;checks if byte is 0
         je        exit                        ;if it is, exit
         mov       bh,al                       ;hold byte in bh register
         mov       cl,4                        ;hold bit shift value 4 in cl
         shr       al,cl                       ;shift al by 4 to get upper 4 bits
         mov       cl,al                       ;move this value into cl
         and       bh,0fh                      ;perform and to get lower 4 bits
         mov       [is_left],1                 ;process top 4 bits value first
;-----------------------------------------------
; Process the 4 bits of input byte and change
; color appropriately
;-----------------------------------------------
left_run:                                      ;
         mov       al,bl                       ;move color value into al for output
         cmp       cl,0fh                      ;is cl value 15
         je        hit_eol                     ;yes, jump to end of line code
         sub       [pels],cl                   ;total pels -= current count
         cmp       bl,[wh]                     ;is the color white
         jne       set_white                   ;if not jump to make it white
         mov       bl,[blk]                    ;change color to black
         jmp       print                       ;ready to print so jump to print
;-----------------------------------------------
; Process what happens when you hit the end of
; a line
;-----------------------------------------------
hit_eol:                                       ;
         mov       cl,[pels]                   ;move remaining pels to cl
         mov       [pels],80                   ;change pel count to 80 for new line
;-----------------------------------------------
; Set color to white
;-----------------------------------------------
set_white:                                     ;
         mov       bl,[wh]                     ;change color to white
;-----------------------------------------------
; Push byte value into output buffer
;-----------------------------------------------
print:                                         ;
         mov       dx,ds                       ;move ds contents into dx
         mov       es,dx                       ;move dx into es to copy ds into es
         rep       stosb                       ;store byte in output buffer
;-----------------------------------------------
; Continue processing values of input
;-----------------------------------------------
         cmp       [is_left],1                 ;check if we are processing left 4 bits
         jne       load                        ;jump to process next value
;-----------------------------------------------
; Process the lower 4 bits of input byte
;-----------------------------------------------
         mov       cl,bh                       ;move lower 4 bits into cl
         mov       [is_left],0                 ;we are not processing top 4 bits
         jmp       left_run                    ;process input
;-----------------------------------------------
; Restore registers and return
;-----------------------------------------------
exit:                                          ;
         pop       di                          ;restore 'C' register
         pop       si                          ;restore 'C' register
         pop       bp                          ;restore 'C' register
         ret                                   ;return
;-----------------------------------------------
         end                                   ;end
;-----------------------------------------------