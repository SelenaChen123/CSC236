Test date: 04/13/20  01:22:50 
The number of times you used the grading program is 2 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.2
Student: St#1=Snezhko              St#2t=Chen                 Type=Team                
Grading program history
   *** Grading Run.  Date: 04/13/20  01:11:15 
   *** Grading Run.  Date: 04/13/20  01:22:50 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++  100 = Points earned for correct answers.

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     2  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC766&}xC6&k~C6&juiC6&zuzC766&Zkyz&jgzk@&6:579586&&67@88@;6&

Building the file arm.ans for electronic submission...
;----------------------------------------------------------------------------------------
;  Program:      ARM KEY
;
;  Function:     Opens an input file named key.in and an output file named key.out. If
;                the character is an upper case letter (A-Z) then write it to the
;                standard output. If the character is a lower case letter (a-z) then
;                convert it to upper case and write it to the standard output. If the
;                character is a blank then write it to the standard output. If the
;                character is a hex zero then move it to the output string. This also
;                signifies the end of the input string. If the character is anything
;                else then do not write it to standard output, just throw the character
;                away. After processing all characters on the input line, write the
;                output string and a carriage return and line feed to the output file.
;
;  Input:        Input file named key.in.
;
;  Output:       Outfile file named key.out.
;
;  Owner:        Selena Chen (schen53)
;                Alex Snezhko (avsnezhk)
;
;  Date:         04/13/2020
;
;  Changes:      04/13/2020    Started and completed
;                04/13/2020    Done goofed
;----------------------------------------------------------------------------------------
;  Software Interrupt Values
;----------------------------------------------------
         .equ SWI_Open,     0x66                    ;open a file
         .equ SWI_Close,    0x68                    ;close a file
         .equ SWI_PrStr,    0x69                    ;write a null-terminated string
         .equ SWI_RdStr,    0x6A                    ;read a string and null terminate it
         .equ SWI_Exit,     0x11                    ;stop execution
;----------------------------------------------------
         .global    _start
         .text
;----------------------------------------------------
;  Open input file
;  - r0 points to the file name
;  - r1 0 for input
;  - the open swi is 66h
;  - after the open r0 will have the file handle
;----------------------------------------------------
_start:                                             ;
         ldr   r0,=InFileName                       ;r0 points to the file name
         ldr   r1,=0                                ;r1 = 0 specifies the file is input
         swi   SWI_Open                             ;open the file
         ldr   r1,=InFileHandle                     ;r1 points to handle location
         str   r0,[r1]                              ;store the file handle
;----------------------------------------------------
;  Open output file
;  - r0 points to the file
;  - r1 1 for output
;  - the open swi is 66h
;  - after the open, r0 will have the file handle
;----------------------------------------------------
         ldr   r0,=OutFileName                      ;r0 points to the file name
         ldr   r1,=1                                ;r1 = 1 specifies the file is output
         swi   SWI_Open                             ;open the file
         ldr   r1,=OutFileHandle                    ;r1 points to handle location
         str   r0,[r1]                              ;store the file handle
;----------------------------------------------------
;  Read a string from the input file
;  - r0 contains the file handle
;  - r1 points to the input string buffer
;  - r2 contains the max number of characters
;  - the read swi is 6ah
;  - the input string will be terminated with 0
;----------------------------------------------------
_read:                                              ;
         ldr   r0,=InFileHandle                     ;r0 points to the input file handle
         ldr   r0,[r0]                              ;r0 has the input file handle
         ldr   r1,=String                           ;r1 holds address of the string
         ldr   r7,=Out                              ;r7 will hold the address of the output string
         ldr   r2,=80                               ;r2 holds number of bytes to read
         swi   SWI_RdStr                            ;read the string from the input file
;----------------------------------------------------
;  Process each character
;----------------------------------------------------
_process:                                           ;
         ldrb  r8,=0                                ;initially store 0 into output buffer position
         strb  r8,[r7]                              ;and then overwrite later if needed
         ldrb  r4,[r1],#1                           ;load the character at current offset
;----------------------------------------------------
;  Check for character validity
;----------------------------------------------------
         cmp   r4,#0                                ;check if r4 is 0 (end of line)
         beq   _write                               ;if so, print
         cmp   r4,#0x1A                             ;check if r4 is eof
         beq   _write                               ;if so, print print
;----------------------------------------------------
;  Translate character with translation table
;----------------------------------------------------
         ldr   r5,=Trans                            ;r5 has translation table offset
         ldrb  r6,[r5,r4]                           ;move the translated letter into r6
         cmp   r6,#0                                ;check if this is invalid
         beq   _process                             ;if invalid then continue to next char
         strb  r6,[r7],#1                           ;write r6 into current character
         bal   _process                             ;read next char
;----------------------------------------------------
;  Write the output string
;----------------------------------------------------
_write:                                             ;
         ldr   r0,=OutFileHandle                    ;r0 points to the output file handle
         ldr   r0,[r0]                              ;r0 has the output file handle
         ldr   r1,=Out                              ;r1 points the output string
         swi   SWI_PrStr                            ;write the null terminated string
;----------------------------------------------------
;  Write the CRLF and read the next line
;----------------------------------------------------
         ldr   r1,=CRLF                             ;r1 points to the CRLF string
         swi   SWI_PrStr                            ;write the null terminated string
;----------------------------------------------------
;  Check if the line was eof
;----------------------------------------------------
         ldr   r1,=String                           ;load r1 with string address to read
         ldrb  r1,[r1]                              ;get the first byte of the line
         cmp   r1,#0x1A                             ;if line was eof, don't write CRLF
         beq   _exit                                ;so do next read
         bal   _read                                ;read the next line
;----------------------------------------------------
;  Close input file
;----------------------------------------------------
_exit:                                              ;
         ldr   r0,=InFileHandle                     ;r0 points to the input file handle
         ldr   r0,[r0]                              ;r0 has the input file handle
         swi   SWI_Close                            ;close the file
;----------------------------------------------------
;  Close output file and terminate
;----------------------------------------------------
         ldr   r0,=OutFileHandle                    ;r0 points to the output file handle
         ldr   r0,[r0]                              ;r0 has the output file handle
         swi   SWI_Close                            ;close the file
         swi   SWI_Exit                             ;terminate the program
;----------------------------------------------------
         .data                                      ;start the data segment
;----------------------------------------------------
InFileHandle:   .skip 4                             ;4 byte field to hold the input
OutFileHandle:  .skip 4                             ;4 byte field to the hold the output
                                                    ;
InFileName:     .asciz "KEY.IN"                     ;input file name, null terminated
                                                    ;
String:         .skip 80                            ;reserve an 80 byte string
Out:            .skip 80                            ;output string buffer
                                                    ;
CRLF:           .byte 13, 10, 0                     ;CR LF
                                                    ;
OutFileName:    .asciz "KEY.OUT"                    ;output file name, null terminated
                                                    ;
Trans:          .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;translation table
                .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;10-19 invalid
                .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;20-29 invalid
                .byte 0, 0, 32, 0, 0, 0, 0, 0, 0, 0 ;32 (space) is valid
                .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;40-49 is invalid
                .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;50-59 invalid
                .byte 0, 0, 0, 0, 0                 ;60-64 invalid
                .ascii "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;A-Z are valid
                .byte 0, 0, 0, 0, 0, 0              ;91-96 invalid
                .ascii "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ;translate a-z to uppercase (valid)
                .byte 0, 0, 0, 0, 0                 ;123-127 invalid
;----------------------------------------------------
         .end                                       ;end
;----------------------------------------------------

